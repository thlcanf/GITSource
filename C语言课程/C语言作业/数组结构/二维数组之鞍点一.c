// 试题描述
// 找出一个m行n列的二维数组A中的鞍点，即该位置上的元素在该行上最大，在该列上最小。也可能没有鞍点。为了简化问题，鞍点是唯一的。请使用数组实现。
// 输入
// 输入包含若干行：
// 第一行是两个整数m和n（3 <= m，n <= 10），用一个空格隔开。m代表二维数组的行数，n代表列数。
// 第二行到第m + 1行，即按照行序输入数组元素。每行有n个整数，相邻两项之间用一个空格隔开。
// 输出
// 输出一行，是鞍点信息；若没有鞍点，则输出“没有鞍点”（不输出引号）。
// 输入示例1
// 6 10
// 9 9 8 9 9 8 9 9 9 15
// 1 2 3 6 4 5 1 8 1 1
// 2 2 2 4 2 2 8 4 2 2
// 1 2 1 2 1 1 1 3 1 2
// 9 9 1 4 6 7 7 8 9 5
// 1 2 2 4 5 6 7 8 9 5
// 输出示例1
// A[3][7]=3是鞍点
// 输入示例2
// 3 3
// 9 2 10
// 8 5 6
// 7 8 9
// 输出示例2
// 没有鞍点
// 数据范围
// 输入为int范围的整数

#include <stdio.h>
int main()
{
    int A[10][10],m, n, i, j, max, min, t, flag = 0, flag1 = 0;
    scanf("%d %d", &m, &n);
    for (i = 0; i < m; i++) //逐行输入数据
    {
        for (j = 0; j < n; j++)
        {
            scanf("%d", &A[i][j]);
        }
    }
    for (i = 0; i < m; i++) //进行鞍点判断
    {
        max = A[i][0];
        for (j = 0; j < n; j++) //求每行最大值
        {
            if (A[i][j] > max)
            {
                max = A[i][j];
            }
        }
        for (j = 0; j < n; j++)
        {
            if (A[i][j] == max) //定位该行最大值以及判断该列最小值
            {
                flag1 = 0;
                min = A[i][j];
                for (t = 0; t < m; t++) //定位
                {
                    if ((A[t][j] < min) && (t != i)) //判断
                    {
                        flag1++;
                        break;
                    }
                }
                if (flag1 == 0)
                {
                    printf("A[%d][%d]=%d是鞍点\n", i, j, max);
                    flag++;
                }
            }
        }
    }
    if (flag == 0)
    {
        printf("没有鞍点");
    }
    return 0;
}